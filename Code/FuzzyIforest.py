# -*- coding: utf-8 -*-
"""IForest_Imp_v2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1v3C0r2DpBKffibJuEAK4Bscj6Q9YLuxI

# Imports
"""

import math
import pandas as pd
import numpy as np
from typing import List

import numpy as np


import abc

"""#  New Implementation

## abstract class
"""


class Node:
    def __init__(self, value, children=None,is_leaf=False,split_value=None,split_attribut=None):
      self.value = value  
      self.children = children
      self.is_leaf = is_leaf
      self.split_value=split_value
      self.split_attribut=split_attribut

class ICustomIForest:
  """
  ICustomIForest abstract class: interface used to generate an Isolation Forest model 
  ----------
  Parameters
  ----------
  number_of_trees : int
      represent the number of trees generated in the forest
  sample_size :int
      represent the size of the sample used to generate the tree
  contamination: float
      The amount of contamination of the data set, i.e. the proportion of outliers in the data set. Used when fitting to define the threshold on the scores of the samples.
      should be between [0,1]
      default value equal to 0.1 
  Methods
  -------
  """

  def __init__(self, number_of_trees: int,sample_size: int = 256,contamination: float = 0.1 ):
    self.number_of_trees = number_of_trees
    self.sample_size = sample_size
    self.forest: List[Node] = None
    self.contamination = contamination
    self.threshold = None
    self.scores = np.array([])

  # inner class node
  # class Node:
  #   def __init__(self, value, children: List[Node]=None,is_leaf=False,split_value=None,split_attribut=None):
  #     self.value = value  
  #     self.children = children
  #     self.is_leaf = is_leaf
  #     self.split_value=split_value
  #     self.split_attribut=split_attribut  

  def fit(self,set):
    self.forest = self._iForest(set)
    self.scores = None
    return self.forest

  def _generate_threshold(self,scores):
    self.threshold = np.percentile(scores,(1-self.contamination)*100)

  #training Stage 
  @staticmethod 
  def _random_split(sample_set):
    pass
  
  
  def _iTree(self,sample_set,current_height: int,height_limit):
    if current_height>= height_limit or sample_set.shape[0]<=1:
        return Node(sample_set,is_leaf= True)
    else:
        partitions,random_split_value,random_attribut= type(self)._random_split(sample_set)
        if  (partitions == None) : return Node(sample_set,is_leaf= True)
        node= Node(sample_set,is_leaf= False,split_value=random_split_value,split_attribut=random_attribut)
        node.children=[]
        for partition in partitions:
          node.children.append(self._iTree(partition,current_height+1,height_limit))
        return node
  
  def _iForest(self,training_set)-> List[Node] :
    forest=[]
    height_limit= math.ceil(math.log(self.sample_size,2))
    for i in range(self.number_of_trees):
        sample_set = training_set[np.random.choice(training_set.shape[0], size=self.sample_size, replace=False),:]
        forest.append(self._iTree(sample_set,0,height_limit))
    return forest
  
  # Evaluation Stage
  @staticmethod  
  def _cost(size: int):
    pass

  @staticmethod
  def _path_length(instance,tree: Node,current_path_length):
    pass
  
  @staticmethod
  def _anomalie_score(estimated_path,set_size: int):
    pass

  def score_samples(self,test_set):
    pass
    
  def predict(self, test_set) :
    predictions = [] 
    scores = []
    if (self.scores.any()):
      scores = self.scores
    else: 
      scores = self.score_samples(test_set)
    self._generate_threshold(scores)
    for score in scores:
      predicted_class = 0 if ( score <= self.threshold ) else 1
      predictions.append(predicted_class)
    return np.array(predictions)

"""## alpha-cut implementation

### fuzzifier API (implemented in Scickit fuzzy notebook )
"""

class AlphaCutIForestModel(ICustomIForest):
  def __init__(self, number_of_trees: int,sample_size: int = 256,contamination: float = 0.1 ):
    super().__init__(number_of_trees,sample_size,contamination)

  @staticmethod
  def _random_split(sample_set, splitable_attributs = None):
    # TODO: implement unsplitable_attributs
    if splitable_attributs != None and len(splitable_attributs) ==0: return None, None, None
    if splitable_attributs == None: splitable_attributs= [*range(sample_set.shape[1])]
    random_attribut=splitable_attributs[np.random.choice(len(splitable_attributs), size=1, replace=False)[0]]
    min=np.amin(sample_set[:,[random_attribut]])
    max=np.amax(sample_set[:,[random_attribut]])
    random_split_value=np.random.uniform(min, max)
    left_partition= sample_set[np.where(sample_set[:,random_attribut]<=random_split_value)]
    right_partition= sample_set[np.where(sample_set[:,random_attribut]>random_split_value)]
    if right_partition.shape[0]*left_partition.shape[0]==0:
      # print("Invalid partitioning! Retrying...")
      # print("min: "+str(min))
      # print("max: "+str(max))
      # print("split: "+str(random_split_value))
      splitable_attributs.remove(random_attribut)
      return AlphaCutIForestModel._random_split(sample_set, splitable_attributs)
    partitions= [left_partition, right_partition]
    return partitions,random_split_value,random_attribut

  def fit(self,set):
    if (type(set)):
      self.forest = self._iForest(set)
    return self.forest

  @staticmethod  
  def _cost(size: int):
    if (size==1): return 0
    return 2*(math.log(size-1)+np.euler_gamma-(1-(1/size)))

  @staticmethod
  def _path_length(instance,tree: Node,current_path_length):
    if tree.is_leaf:
      return current_path_length+AlphaCutIForestModel._cost(tree.value.shape[0])
    if instance[tree.split_attribut]<=tree.split_value:
      return AlphaCutIForestModel._path_length(instance,tree.children[0],current_path_length+1)
    else:
      return AlphaCutIForestModel._path_length(instance,tree.children[1],current_path_length+1)
  
  @staticmethod
  def _anomalie_score(estimated_path,set_size: int):
    return math.pow(2,-(estimated_path/AlphaCutIForestModel._cost(set_size)))

  def score_samples(self,test_set):
    if not(self.forest):
      return None
    scores=[]
    forest_size=len(self.forest)
    for i in range(test_set.shape[0]):
      instance= test_set[i,:]    
      s=0
      for j in range(forest_size):
        s += AlphaCutIForestModel._path_length(instance,self.forest[j],0)
      score = AlphaCutIForestModel._anomalie_score(s/forest_size,forest_size)
      scores.append(score)
    self.scores = np.array(scores)
    return np.array(scores)


