# -*- coding: utf-8 -*-
"""Iforest_implementation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oAKec_IHlC1ckIZjRc-OEW0x3HQVGUjb

# Imports
"""



import math
from sklearn.ensemble import IsolationForest
import numpy as np
from typing import List

"""# Implementation"""

class Node:

  def __init__(self, value, left=None, right=None,is_leaf=False,split_value=None,split_attribut=None):
      self.value = value  
      self.left = left    
      self.right = right
      self.is_leaf = is_leaf
      self.split_value=split_value
      self.split_attribut=split_attribut



class CustomIForestModel:

  def __init__(self, number_of_trees: int,sample_size: int = 256,contamination: float = 0.1 ):
    self.number_of_trees = number_of_trees
    self.sample_size = sample_size
    self.forest: List[Node] = None
    self.contamination = contamination
    self.threshold = None

  def fit(self,set):
    self.forest = self.__iForest(set)
    return self.forest

  def __generate_threshold(self,scores):
    self.threshold = np.percentile(scores,(1-self.contamination)*100)

  #training Stage 
  @staticmethod 
  def __random_split(sample_set):
    random_attribut=np.random.choice(sample_set.shape[1], size=1, replace=False)[0]
    min=np.amin(sample_set[:,[random_attribut]])
    max=np.amax(sample_set[:,[random_attribut]])
    random_split_value=np.random.uniform(min, max)
    left_partition= sample_set[np.where(sample_set[:,random_attribut]<=random_split_value)]
    right_partition= sample_set[np.where(sample_set[:,random_attribut]>random_split_value)]
    if right_partition.shape[0]*left_partition.shape[0]==0:
      print("Invalid partitioning! Retrying...")
      return CustomIForestModel.__random_split(sample_set)
    return left_partition,right_partition,random_split_value,random_attribut
  
  @staticmethod
  def __iTree(sample_set,current_height: int,height_limit):
    if current_height>= height_limit or sample_set.shape[0]<=1:
        return Node(sample_set,is_leaf= True)
    else:
        left_partition,right_partition,random_split_value,random_attribut= CustomIForestModel.__random_split(sample_set)
        node= Node(sample_set,is_leaf= False,split_value=random_split_value,split_attribut=random_attribut)
        node.left=CustomIForestModel.__iTree(left_partition,current_height+1,height_limit)
        node.right=CustomIForestModel.__iTree(right_partition,current_height+1,height_limit)
        return node
  
  def __iForest(self,training_set)-> List[Node] :
    forest=[]
    height_limit= math.ceil(math.log(self.sample_size,2))
    for i in range(self.number_of_trees):
        sample_set = training_set[np.random.choice(training_set.shape[0], size=self.sample_size, replace=False),:]
        forest.append(CustomIForestModel.__iTree(sample_set,0,height_limit))
    return forest
  
  # Evaluation Stage
  @staticmethod  
  def __cost(size: int):
    if (size==1): return 0
    return 2*(math.log(size-1)+np.euler_gamma-(1-(1/size)))

  @staticmethod
  def __path_length(instance,tree: Node,current_path_length):
    if tree.is_leaf:
      return current_path_length+CustomIForestModel.__cost(tree.value.shape[0])
    if instance[tree.split_attribut]<=tree.split_value:
      return CustomIForestModel.__path_length(instance,tree.left,current_path_length+1)
    else:
      return CustomIForestModel.__path_length(instance,tree.right,current_path_length+1)
  
  @staticmethod
  def __anomalie_score(estimated_path,set_size: int):
    return math.pow(2,-(estimated_path/CustomIForestModel.__cost(set_size)))

  def score_samples(self,test_set):
    if not(self.forest):
      return Null
    scores=[]
    forest_size=len(self.forest)
    for i in range(test_set.shape[0]):
      instance= test_set[i,:]    
      s=0
      for j in range(forest_size):
        s += CustomIForestModel.__path_length(instance,self.forest[j],0)
      score = CustomIForestModel.__anomalie_score(s/forest_size,forest_size)
      scores.append(score)
    return np.array(scores)
    
  def predict(self, test_set) :
    predictions = [] 
    scores = self.score_samples(test_set)
    self.__generate_threshold(scores)
    for score in scores:
      predicted_class = 0 if ( score <= self.threshold ) else 1
      predictions.append(predicted_class)
    return np.array(predictions)

"""# Testing new implementation"""

